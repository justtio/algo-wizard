## 最大子数组和

给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
子数组 是数组中的一个连续部分。

```
示例 1：
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6

解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。

示例 2：
输入：nums = [1]
输出：1

示例 3：
输入：nums = [5,4,-1,7,8]
输出：23
 
提示：

1 <= nums.length <= 105
-104 <= nums[i] <= 104

进阶：如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。
 
```

这道题其实是动态规划的一种体现，我们通过前一步的结果，来决定当前这一步的最优选择。

```js
var maxSubArray = function(nums){
  //处理空数组的情况
  if(!nums || nums.length === 0) {
    return 0;
  }

  //初始化currentSum和maxSum
  let currentSum = nums[0];
  let maxSum = nums[0];

  //从第二个元素开始遍历
  for(let i = 1; i < nums.length; i++) {
    const num = nums[i];

    //动态规划的核心思想：
    //如果当前和currentSum加上新数字还不如新数字本身大
    //就说明之前的子数组已经对和产生负面影响了
    //那我们就放弃之前的子数组，从当前数字重新开始
    currentSum = Math.max(num, currentSum + num);

    //每次更新完currentSum后，都检查它是否是目前找到的最大和
    maxSum = Math.max(currentSum, maxSum);
  }
  return maxSum;
}
```

我们接着来看一下分治法是怎么解决这个问题的。其实在时间复杂度上分治法是O(nlogn)
,但是它提供一种新视角让我们看待这个问题。

```js
var maxSubArray = function(nums) {
  //处理边界情况
  if(!nums || nums.length === 0) {
    return 0;
  }

  //调用分治法主函数，传入整个数组和其首尾索引
  return maxSubArrayDivideNConquer(nums, 0, nums.length - 1);
}

const maxSubArrayDivideNConquer = (nums, left, right) => {
  //递归终止条件：当子数组只有一个元素时
  if(left === right) return nums[left];

  //找到中点
  const mid = Math.floor((left + right) / 2);

  //递归求解左右部分的最大子数组和
  const leftMaxSum = maxSubArrayDivideNConquer(nums, left, mid);
  const rightMaxSum = maxSubArrayDivideNConquer(nums, mid + 1, right);

  //求解跨中线的最大子数组和
  const crossingMaxSum = findMaxCrossingSubarray(nums, left, mid, right);

  //比较三者，返回最大值
  return Math.max(leftMaxSum, rightMaxSum, crossingMaxSum);
}

const findMaxCrossingSubarray = (nums, left, mid, right) => {
  //求解左半部分的最大子数组和，必须包含mid
  let leftSum = -Infinity;
  let currentSum = 0;
  for(let i = mid; i >= left; i--) {
    currentSum += nums[i];
    if(currentSum > leftSum) {
      leftSum = currentSum;
    }
  }

  //求解右半部分最大子数组和，必须包含mid + 1；
  let rightSum = -Infinity;
  currentSum = 0;
  for(let i = mid + 1; i <= right; i++) {
    currentSum += nums[i];
    if(currentSum > rightSum) {
      rightSum = currentSum;
    }
  }

  return leftSum + rightSum;
}
```

