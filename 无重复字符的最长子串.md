## 无重复字符的最长字串
[LeetCode原题链接](https://leetcode.cn/problems/wtcaE1/description/)

给定一个字符串 `s` ，请你找出其中不含有重复字符的最长子串的长度。
```
示例 1：
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子字符串是 "abc"，所以其长度为 3。

示例 2：
输入: s = "bbbbb"
输出: 1
解释: 因为无重复字符的最长子字符串是 "b"，所以其长度为 1。

示例 3：
输入: s = "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。

示例 4：
输入: s = ""
输出: 0
 
提示：
0 <= s.length <= 5 * 104
s 由英文字母、数字、符号和空格组成
```
咱们先不看题，先进入我们的邪修领域。假设你是一个动漫白毛角色爱好者，某个周末，你跟你对象在逛街的时候看到一家卖手办的店，店里面有一个很神奇的柜子。柜子其中的一排摆的全是白毛，各个都是你想收藏的心头好，都想带回家。但是你对象说这样不行，全带回去太奢侈了，所以她给你提了个要求，你只能选择一排柜子上连续且不同的白毛角色带回家，具体能带多少回家就要看你本事了。你心想这也太简单了，便一口答应下来。
此时柜子的白毛角色如下所示：

`自来也` - `五条悟` - `小黑` - `五条悟` - `坂田银时` - `小黑` - `坂田银时` - `金木研` - `金木研`

你快速用眼睛扫了一眼，就知道不妙，这次最多只能带三个回去(具体是哪三个就要看你对角色的个人喜好了)。你看你是不是很简单就找出答案了，但是这个柜子一排要是有一百个手办，你是不是就没有那么快能得到答案了。这个时候如果你会一点算法的话，那这种情况你也能迎刃而解，你看（运行）一遍，你也马上就能知道答案了。

好，这次我们再来回到这道算法题。你看是不是跟我们刚刚说的这个场景是一模一样的。你看这个s字符串就是柜子上的那排白毛手办。我们以此为例来分解一下这个题。

- “自"没有重复子串，长度为1（1手办get）
- “自-五”没有重复子串，长度为2（2手办get）
- “自-五-小”没有重复子串，长度为3（3手办get）
- “自-五-小-五”有重复字串，因为有四个2.5条五，所以这里有重复了就停了。
（我们现在从五开始重新算，加速...）
- “五-坂-小”没有重复子串（3手办get）
- “五-坂-小-坂”又有重复子串了
（我们现在又只能再从小开始算）
- “坂-金”没有重复子串（2手办get）
- “坂-金-金”有重复子串，但此时柜子上的手办你已经看光了，你的手办选择之旅就结束了。

  此时你看按照你对象的规则，你最多能从柜子上带走三个手办，这个时候你只能怪售货员怎么这么摆货呢。
  在上述这个过程其实你运用到了一个名为“滑动窗口”方法，这个方法非常神奇，让你能够只扫一遍所有的手办，你就知道你最多能带走几个手办。当然它可能不能得出你最想要那组手办（子串），我们这次重点关注的是，最终你最多能带走的手办个数。而咱们自己买手办的时候还是可以灵活一些的，选择自己最喜欢的连续组合，倘若如果其中出现的白毛组合都是你没买过且想要的，那就另当别论了，下回我们也可以讲讲怎么把所有符合最长子串的组合统统找出来，这个问题你们也可以思考一下，我就不在这里展开了。

  好了，为了能够顺利带走最多的手办，我们做点准备工作。
  - 一个框子（我们的滑动窗口）：这个框会从左往右移动，就像我们的眼睛焦点一样，框里的手办就是我们正在检查的手办。
  - 一个袋子: 用来放框里的手办，但是这个袋子有个特性，不能放重复的手办，一旦遇到重复的手办，想要再放就得把之前放的都拿出来。
  - 一个本子：用来记录我们最多能带走几个手办（也就是无重复子串最多能有多长）。
 
  整个过程就是，你的视线从左往右扫描，框子开始移动（窗口开始滑动，这也是为什么叫滑动窗口），你的眼神焦点每次集中到某个手办上的时候，你就准备把它往袋子里放，但是放之前你要检查一下，你放的这个在袋子中有没有相同的手办，如果有的话，那就只能把袋里面之前放的手办都拿出来，再把这个放进去，从这个手办窗口重新开始滑动，然后重复这个行为。每一轮中都在本子上记录，你最多能带走几个手办，等到你的框子（焦点）移到最后手办身上，整个过程就结束了，这个时候你再看你本子上记的是数字几，就表示你最多能够带走几个手办。

接下来让我们来看一下，这整个过程用代码该怎么表示。（笔者是个前端，因此代码我就用JS演示了，很好懂的）

```js
/**
*@param {string} s 【那一排手办】
*@return {number} 【最后能带走的最大手办数】
*/
var lengthOfLongestSubstring = function(s) {
  //Set()就是我们的袋子，里面不允许有重复手办
  const dollSet = new Set(); //首先拿到一个袋子
  let left = 0; //框子的左侧标记
  let maxLen = 0; //有个计数的本子
  //你的眼睛焦点也开始移动，直到你看完所有手办（就是right到s.length - 1的时候）
  for(let right = 0; right < s.length; right++) {
    const doll = s[right]; //正在聚焦的手办
    //检查袋子中是否有重复手办，如果有的话，就需要把袋子中之前放的手办都拿出来，从最新聚焦的这个手办重新放
    while(dollSet.has(doll)) {
      dollSet.delete(s[left]); //把之前放进去的手办一个个拿出来
      left++；//移动到最新聚焦的手办上
    }

    //没有重复，就把手办放进袋子中
    dollSet.add(doll);
    maxLen = Math.max(maxLen, right - left + 1); //把最大手办数记在本本上；
  }
  return maxLen; //你最多可以带回家的手办数
}
```
```
//我们仔细想一下，其实使用set数据结构并非是最优解，会产生一些冗余步骤，比如要一步步移动left，一步步拿出袋子里的手办,，可以但没必要。
//所以介于这种考量，我们使用map，原理过程都是类似的，时间空间复杂度也基本一致，只不过是把框子和袋子合而为一了，直接为环保做贡献了。
var lengthOfLongestSubstring = function(s) {
     const dollMap = new Map();
     let left = 0,
     maxLen = 0;
     //通过左右指针维护的滑动窗口来直接作为手办的无重复的容器
     for(let right = 0; right < s.length; right++){
          const doll = s[right];
          if(dollMap.has(doll) && dollMap.get(doll) >= left) {
               left = dollMap.get(doll) + 1;
          }
          dollMap.set(doll, right);

          maxLen = Math.max(maxLen, right - left + 1);
     }
     return maxLen;
}
```
时间复杂度：O(n);
空间复杂度：O(min(m, n));

你看是不是很简单就解决了，除了在特定情况下买手办，找到最大的无重复子串在现实生活中也有一些其他的应用。

- 大学论文的查重，核心就是依据这个理念
- 再比方说设置密码时，无重复字符来判断密码的强度怎么样，是否可靠
- 或者输入法的猜你想输入的话，也多少遵循这样类似的原理
- 基因对比，发现是否有变异风险

所以其实算法在我们生活中其实无处不在，算法没有那么可怕，学习算法思想，能让人的思维更敏锐，甚至能让你养成一套更高效思维方式、提升自身解决问题的能力，让你对这个世界看得更加通透，所以还等什么呢，快来跟算法邪修学算法吧。包教包会的！！！
