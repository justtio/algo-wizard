## 岛屿数量

给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

```js
示例 1：
输入：grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
输出：1

示例 2：
输入：grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
输出：3
 
提示：
m == grid.length
n == grid[i].length
1 <= m, n <= 300
grid[i][j] 的值为 '0' 或 '1'
```

```js
var numIslands = function(grid) {
  if(!grid || grid.length === 0) return 0;

  const rows = grid.length;
  const cols = grid[0].length;
  let numIslands = 0;

  //深度优先搜索，用于淹没一个完整的岛屿
  const dfs = (r, c) => {
    //如果越界，或者当前格子是海洋，停止递归
    if(r < 0 || r >= rows || c < 0 || c > cols || grid[r][c] === '0') return;

    //将当前陆地淹没，防止重复计算
    grid[r][c] = '0';

    //递归地从上下左右四个方向探索
    dfs(r + 1, c); //下
    dfs(r - 1, c); //上
    dfs(r, c + 1); //右
    dfs(r, c - 1); //左
  };

  //遍历地图上的每一个格子
  for(let r = 0; r < rows; r++) {
    for(let c = 0; c < cols; c++) {
      if(grid[r][c] === '1') {
        numIslands++;
        // 从这块陆地开始，用DFS淹没岛屿
        dfs(r, c);
      }
    }
  }

  //返回岛屿总数
  return numIslands;
}
```

我们尝试使用广度优先的方式再写一遍。

```js
var numIslands = function(grid) {
  if(!grid || grid.length === 0) return 0;

  const rows = grid.length;
  const cols = grid[0].length;
  let numIslands = 0;

  for(let r = 0; r < rows; r++) {
    for(let c = 0; c < cols; c++) {
      if(grid[r][c] === '1') {
        numIslands++;
        //开启BFS搜索，从当前位置开始
        const queue = [[r, c]];
        grid[r][c] = '0';

        //只要队列不为空，就继续探索
        while(queue.length > 0) {
          const [currR, currC] = queue.shift();

          //定义四个方向的偏移量
          const directions = [[1, 0], [-1, 0], [0, 1], [0, -1]];

          for(const [dr, dc] of directions) {
            const newR = currR + dr;
            const newC = currC + dc;

            // 检查新位置是否在界内且是陆地
            if(newR >= 0 && newR < rows && newC >= 0 && newC < cols && grid[newR][newC] === '1') {
              //将新陆地标记为已探索
              grid[newR][newC] = '0';
              //将其加入队列，以待后续探索
              queue.push([newR, newC]);
            }
          }
        }
      }
    }
  }
  return numIslands;
}
```

