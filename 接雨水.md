## 接雨水

给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

```
示例 1：
输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出：6
解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 

示例 2：
输入：height = [4,2,0,3,2,5]
输出：9
 
提示：
n == height.length
1 <= n <= 2 * 104
0 <= height[i] <= 105
```

```js
var trap = function(height) {
  //如果数组为空，且小于3，则不能接住雨水
  if(!height || height.length < 3) return 0;

  const n = height.length;
  //创建两个数组来储存左右最高墙的高度
  const leftMax = new Array(n).fill(0);
  const rightMax = new Array(n).fill(0);
  let totalWater = 0;

  //第一次遍历：从左到右，计算每个位置左边的最高墙
  leftMax[0] = height[0];
  for(let i = 1; i < n; i++) {
    leftMax[i] = Math.max(leftMax[i - 1], height[i]);
  }

  //第二次遍历，从右往左，计算每个位置右边的最高墙
  rightMax[n - 1] = height[n - 1];
  for(let i = n - 2; i >= 0; i--) {
    rightMax[i] = Math.max(rightMax[i + 1], height[i]);
  }

  //第三次遍历。计算每个位置的接水量并累加
  //两端的柱子无法接水，可以从索引1开始到n-2
  for(let i = 0; i < n; i++) {
    //水位的高度取决于左右两边高墙中较矮的那个
    const waterLevel = Math.min(leftMax[i], rightMax[i]);
    //如果水位高于当前柱子，则可以接住雨水
    if(waterLevel > height[i]) {
      totalWater += waterLevel - height[i];
    }
  }
  return totalWater;
}
```

```js
//双指针法
/**
 * 每次移动较低一侧的指针，并更新该侧的最大高度
 * 当前柱子的水量等于当前最大高度减去柱子的高度。
 */
var trap = function(height) {
  let left = 0, right = height.length - 1;
  let leftMax = 0, rightMax = 0;
  let totalWater = 0;

  while(left < right) {
    if(height[left] < height[right]) {
      //左侧较低，处理左指针
      leftMax = Math.max(leftMax, height[left]);
      totalWater += leftMax - height[left];
      left++;
    }else {
      rightMax = Math.max(rightMax, height[right]);
      totalWater += rightMax - height[right];
      right--
    }
  }
  return totalWater;
}
```