## 二叉树的最近公共祖先

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

```
示例 1：
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出：3
解释：节点 5 和节点 1 的最近公共祖先是节点 3 。

示例 2：
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出：5
解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。

示例 3：
输入：root = [1,2], p = 1, q = 2
输出：1
 
提示：
树中节点数目在范围 [2, 105] 内。
-109 <= Node.val <= 109
所有 Node.val 互不相同 。
p != q
p 和 q 均存在于给定的二叉树中。
```

```js
/**
 * function TreeNode(val) {
 *  this.val = val;
 *  this.left = this.right = null;
 * }
 */

var lowestCommonAncestor = function(root, p, q) {
  //递归的基准情况
  //如果根节点为空，或者找到p或者q，直接返回该节点
  if(root === null || root === p || root === q) return root;

  //递归地向左子树和右子树寻找
  const leftResult = lowestCommonAncestor(root.left, p, q);
  const rightResult = lowestCommonAncestor(root.right, p, q);

  //根据左右子树的递归结果进行判断
  // 如果左右子树都找到了非空结果
  // 说明p和q分别位于当前节点的两边，那么当前节点就是LCA
  if(leftResult && rightResult) {
    return root;
  }

  //如果只有左子树找到了结果，说明p和q都在左子树中
  //那么继续向上返回左子树结果
  if(leftResult) return leftResult;

  //如果只有右子树找到了结果，说明p和q都在右子树中
  //那么继续向上返回右子树的结果
  if(rightResult) return rightResult;

  //如果左右子树都返回null，说明p和q都不在当前子树中
  return null;
}
```