## 三数之和
给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请你返回所有和为 0 且不重复的三元组。

注意：答案中不可以包含重复的三元组。

```
示例 1：
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]

解释：
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。
不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。
注意，输出的顺序和三元组的顺序并不重要。

示例 2：
输入：nums = [0,1,1]
输出：[]

解释：唯一可能的三元组和不为 0 。

示例 3：
输入：nums = [0,0,0]
输出：[[0,0,0]]

解释：唯一可能的三元组和为 0 。


提示：
3 <= nums.length <= 3000
-105 <= nums[i] <= 105
```

### 代码题解
先把数组进行排序，然后固定一个数，剩下用双指针找
如果找到和为0的三元 组就保存，同时需要注意去重
```js
//排序➕双指针法
var threeSum = function(nums) {
  //数组排序
  nums.sort((a, b) => a - b);
  const res = [];

  //遍历数组，固定第一个数
  for(let i = 0; i < nums.length - 2; i++) {
    //跳过重复的第一个数
    if(i > 0 && nums[i] === nums[i - 1]) continue;

    //双指针查找剩余两个数
    let left = i + 1;
    let right = nums.length - 1;

    while (left < right) {
      const sum = nums[i] + nums[left] + nums[right];

      if(sum === 0) {
        //找到符合条件的三元组
        res.push([nums[i], nums[left], nums[right]]);

        //跳过重复的左指针数字
        while(left < right && nums[left] === nums[left + 1]) left++;
        //跳过重复的右指针数字
        while(left < right && nums[right] === nums[right - 1]) right--;

        //移动指针，继续查找
        left++;
        right--;
      }else if(sum < 0) {
        //sum太小，移动left
        left++;
      }else {
        //sum太大，移动right
        right--
      }
    }
  }
  return res;
}
```
时间复杂度：O(n^2)，外层遍历 + 内层双指针
空间复杂度：O(1)，只用常数空间（结果不算）

先“格式化”数据方便后续操作，双指针的思想真的非常好用。解决算法题，实际上只要理解，你有一个问题，然后通过思考把问题拆解出来，再针对问题来找答案，其实还是挺简单的，要培养自己拆解问题的能力，做题解，写算法就是这样一个步骤，是不是很有趣。

如果数组中重复元素很多的话，我们其实还有一种更为“优雅”的解法--计数+唯一值枚举。

核心思想：
1. 先把每个数出现的次数频率统计出来，取出排序后唯一值数组。
2. 枚举a，b（确保a <= b），计算c = -(a + b), 只在c >= b 且 c在频次表中把三元组加入答案
3. 对于重复计数做严格检查（例如 a === b === c 需要频次 >= 3，a === b != c 需要a 的频次>=2），这样既避免重复也保证了元素下标可选。

```js
var threeSumByCounts(nums) {
  //把下标映射到值+计数，方便去重与可用性检查
  const cnt = new Map();
  for(const x of nums) {
    cnt.set(x, (cnt.get(x) || 0) + 1);
  }

  //取出所有不同的数并排序称uniq（升序
  const uniq = Array.from(cnt.keys()).sort((a, b) => a - b);

  const res = [];
  const m = uniq.length;

  for(let i = 0; i < m; i++) {
    const a = uniq[i];

    if(a > 0) break;

    //内层从i开始枚举b 确保a <= b
    for(let j = i; j < m; j++) {
      const b = uniq[j];
      const c = -(a + b);

      if(c < b) continue;

      if(!cnt.has(c)) continue;

      if(a === b && b ===c) {
        if(cnt.get(a) >= 3) res.push([a, b, c]);
      }else if(a === b && b !== c) {
        if(cnt.get(a) >= 2) res.push([a, b, c]);
      }else if(a !== b && b === c) {
        if(cnt.get(b) >= 2) res.push([a, b, c]);
      }else {
        res.push([a, b, c]);
      }
    }
  }

  return res;
}
```