## LRU缓存机制
[LeetCode原题链接](https://leetcode.cn/problems/lru-cache/)

请你设计并实现一个满足  LRU (最近最少使用) 缓存 约束的数据结构。
实现 LRUCache 类：
LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存
int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。
void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。
进阶：函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。
```
示例：
输入
["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
输出
[null, null, null, 1, null, -1, null, -1, 3, 4]

解释
LRUCache lRUCache = new LRUCache(2);
lRUCache.put(1, 1); // 缓存是 {1=1}
lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}
lRUCache.get(1);    // 返回 1
lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}
lRUCache.get(2);    // 返回 -1 (未找到)
lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}
lRUCache.get(1);    // 返回 -1 (未找到)
lRUCache.get(3);    // 返回 3
lRUCache.get(4);    // 返回 4
 
提示：
1 <= capacity <= 3000
0 <= key <= 10000
0 <= value <= 105
最多调用 2 * 105 次 get 和 put
```
咱们先不看题，先进入我们的邪修领域，我们都假设你是一个非常热爱读书、热爱摄入各种“知识”的三好青年，你家里有个非常大的异次元书架（书架上各类书籍一应俱全），以及一个非常小且脆书桌，只能叠放下三本书--三本你近期的心头好，最近时常拿起来研读的那种。
好现在让我们将视线移至你的书桌，现在书桌上从上至下叠放着书籍如下：

《白毛的诱惑》|《丝袜的多重用途》|《邂逅兔耳娘》 

今晚你突然想研究一下如何邂逅兔耳娘，于是乎你就把它从底部抽了出来，研读一晚上后将其放回了书堆，此时书桌上三本书的是：

《邂逅兔耳娘》|《白毛的诱惑》|《丝袜的多重用途》

翌日，你又想研究一下如何使用丝袜，你就又把丝袜抽了出来，读完之后受益良多，常读常新，你便心满意足的将其放回了书桌，此时书桌的状态是：

《丝袜的多重用途》|《邂逅兔耳娘》|《白毛的诱惑》

终有一日，你在你的异次元书架上发现了一本神书：《母猪的产后护理》，你细细研读，顿感《白毛》好像没啥意思，你就把它抽出来放回书架，把《母猪》放到了桌上，这个时候书桌上的书变成了：

《母猪的产后护理》|《丝袜的多重用途》|《邂逅兔耳娘》

其实上述整个流程就是LRU缓存的原理，LRU(Least Recently use)，现在来让我们回到这道算法题。
题目要求我们构建一个LRUCache类，其中包含，get，put以及display（就是展示最后数据啥样）等方法。我们来试着用JS代码实现一下，应该是不难的。

```
//关键在于整个增删过程中数据必须保持规则上的有序，因此我们便想到使用Map数据结构来实现应该挺合适的

```

